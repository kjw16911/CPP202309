bool 타입에서 0 이외의 숫자는 모두 참으로 반환

* 조건문
프로그램이 특정 조건에 따라 다른 동작을 수행하도록 하는 프로그래밍 구조
-if-else문
if
if-else
중첩 if-else


* switch문 (파이썬에는 없음)
케이스에 따라 다른 동작을 수행할 때 사용되는 제어구조
표현식의 결과값이 case에 들어가는 값과 같은지를 확인

break문
break를 쓰지 않을 경우 계속해서 문장을 실행시킴.
아래 문장을 더 이상 실행시키지 않겠다.

if문과 switch문은 같은 기능을 하게끔 만들 수 있음.

-증감연산자
선행 증감
후행 증감
취향에 따라 사용

-반복문
for (초기식 ; 조건식 ; 증감식) => 리스트 순회
{	수행코드
}

while (조건식) : 조건식을 확인하고 참이면 문장 수행 => 사용자 입력 처리
{	수행코드
}

do_while       : 문장을 1번 수행하고 조건식을 확인함. 확인 후 참이면 문장 수행
do {	수행코드
 } while(조건식)
=> 메뉴 선택(사용자에게 질문을 하는 경우에 사용됨)

-break문 : 반복문을 즉각 종료

-continue문 : 다음 반복을 즉각 진행

-이중조건문 : 조건문 안에 조건문을 겹치게 작성. n중으로도 가능

-이중반복문 : 반복문 안에 반복문을 겹치게 작성. n중으로도 가능

c랑 c++은 배열에서 같은 자료형으로 넣어야됨.

* 기말 대체 프로젝트
주제 선정 및 기능 계획
필요 함수 및 클래스 구현
포인터 적용

* 디버깅
소프트웨어에서 오류를 찾고 수정하는 과정
- 오류가 난 부분 근처에 값을 출력
=> 직접 눈으로 어떤 변수가 오류인지 확인할 수 있음.

디버거 : 실행 중인 프로그램 상태를 모니터링/제어하는 도구
	- 변수 모니터링 : 실행 중인 변수 값 모니터링
	- 스텝 실행 : 각 문장 단위로 실행을 진행
	- 중단점 설정 :  
	- 스택 추적 : 
	- 메모리 상태 확인 : 
	- 변수 값 설정 : 
1. 
2.
3. 
4. 한 줄 씩 실행
 F10 : 현재 함수 내에서 다음 줄 이동	
 F11 : 함수 내부로 들어가면서 다음 줄 이동

* 함수
함수를 정의할 때 사용한 반환형과 body에 return하는 반환값의 자료형이 일치해야함.
매개변수를 미리 초기화할 수 있음 - 함수를 선언할 때 변수에 값을 입력
매개변수가 없는 경우도 있음 - 그럴 때는 () 안을 비우거나 void를 작성

함수의 반환값 (return value)
함수가 끝나면 밖으로 반환되는 값으로 변수나 상수 값이 반환됨.
return이라는 예약어를 사용하여 함수 종료시킴.
반환값이 없는 경우 함수 앞에 void를 작성
void를 사용할 때는 return 사용 금지

main함수
매개변수 int argc, char*argv[] ...

함수 원형 선언하기
이유 : 컴파일러는 소스 코드를 번역할 때, 위에서 아래 방향으로 변역
피호출자가 호출자 위쪽에 있는 경우 오류 없음
-> 컴파일러가 피호출자를 이미 알고 있기 때문
피호출자가 호출자 아래쪽에 있는 경우 오류 발생
-> 컴파일러가 피호출자를 알지 못하기 때문에 호출 관련 코드 구성 불가

함수 원형을 선언할 때 함수명, 매개변수, 반환형을 포함한 표현식으로 
자세한 함수를 작성하기 전 미리 호출하는 용도

헤더파일로 함수 관리하기
헤더파일이란 함수, 클래스, 변수 등의 선언을 포함하는 텍스트 파일
미리 헤더 파일을 만들어 놓으면 #include "파일명"을 통해 관련 코드를 사용 가능
소스코드가 길고 소스파일이 많아질수록 관리가 어렵기 때문에 헤더 파일을 만들어서 관리함.

함수 원형을 선언할 때
위에 전역 변수를 선언하고
함수를 만드는 과정에 변수를 선언하는 것은 지역변수

참조자 : 기존 변수에 대한 별명을 만드는 것

-문자열
문자열 제거
문자열 찾기
특정 위치부터 문자열 찾기
s.find("," , 4)
4번 인덱스 이후로 ","가 어디 있는지 찾음


#202311-13
생성자 : 객체의 초기화 담당
생성자를 선언할 때는 ()안에서 초기화할 수 있고 {}안에서 초기화할 수도 있음

소멸자 : 객체가 사용한 리소스를 해체하고 정리하는 역할을 담당
~를 앞에 작성하여 소멸자를 호출할 수 있음.
프로그램이 꺼질 때 소멸자가 호출됨.

Get : 정보를 가져옴
Set : 정보를 설정함

#202311-20
▶ 포인터(*)
주소를 저장시킴
- & 주소 연산자
- 역참조
바이트 탐색 후 주소에 저장된 값을 가져옴

▶ 동적 메모리
- 히프 : 아직 사용하지 않은 메모리 공간
   -> 동적 메모리 히프로부터 할당 받는 메모리
- 스택 : 함수 호출과 관련된 정보를 저장하는데 사용되는 메모리 (함수 호출과 관련됨)
- 동적 메모리 사용 후에는 할당 받은 메모리를 반납해야 됨. 중요!
- 할당 : new 연산자
- 해제 : delete 연산자

▶ 스마트 포인터 unique_ptr
- 벡터와 비슷
- 자동으로 동적 메모리 해제시켜주는 기능
- memory 헤더파일 추가
- 자료형와 자료 이름, new 작성
- 배열을 가지고 활용할 때 유용함

▶ 객체의 동적 생성
- 동적 객체 생성
*와 new 사용
동적 객체의 함수에 접근할 때 -> 사용

-this 포인터
this-> 객체에 참조

-const 키워드
멤버 변수를 고정시키기 위한 키워드

C++프로그래밍및실습(23.11.27.)
13주차 상속
-상속이 왜 필요한가?
변수가 중복되어 표현될 수 있기 때문에 효율적으로 사용하기 위해
상위 클래스를 만들어 하위 클래스에 상속하여 변수를 사용할 수 있도록 하는것

클래스를 정의할 때 상속받기 위해 : public 클래스명 작성

상속 클래스는 여러 단계로도 이루어질 수 있음.

- 상속에서의 생성자와 소멸자 ( 상속 생성자 Shape.cpp 확인)
부모 클래스의 생성자가 먼저 호출되고 자식 클래스의 생성자가 호출된다.
소멸될 때는 자식 클래스의 소멸자가 먼저 호출되고 부모 클래스의 소멸자가 호출된다.

-멤버함수 재정의(오버라이딩)
부모 클래스에서 상속 받은 멤버함수를 자식클래스가 필요에 따라서 멤버함수를 재정의할 수 있음

-멤버함수 중복정의(오버로딩)
같은 이름의 함수지만, 매개변수가 달라 다른 기능 수행

- 부모 클래스를 상속 받는 3가지 방법
public
protected
private

-다중 상속
여러 클래스를 부모 클래스로 하여 멤버를 상속 받는 자식 클래스를 만들 수 있음

C++프로그래밍및실습(23.11.29.수)
13주차 다형성과 가상함수

- 연산자 중복 정의와 프렌드 함수
operator 연산자를 통해 함수처럼 작성
클래스 내부에서도 연산자 중복정의할 수 있음

- 프렌드 함수
접근 지정자에 관계 없이 접근 가능

- 다형성이란
객체들의 타입이 다르면 똑같은 메시지가 전달되더라도 
서로 다른 동작을 하는 것
머드 게임에 사용자 2명으로 확장시킬 때 활용 가능할 것 같음

- 상속과 객체 포인터
자식 클래스 객체는 부모 클래스 객체를 포함하고 있음

- 상향 형변환이 왜 필요할까?
서로 다른 객체를 동일하게 사용하고 싶을 때
=> 배열/벡터는 같은 자료형/클래스만 담을 수 있음

- 계속해서 상향 형변환이 되어 Animal speak만 출력되는 문제가 발생
=> 해결책 : 가상함수

- 가상함수
virtual 키워드
다형성을 구현하기 위한 개념
가상 함수로 선언하면 자식 클래스에서 재정의될 수 있고,
런타임의 실제 객체 타입에 따라 출력됨.
- 바인딩
함수 호출이 실제로 어떻게 연결되는지 나타내는 개념
동적 바인딩 : 가상 함수
정적 바인딩 : 일반 함수

-순수 가상함수
정의 방법
virtual 함수 원형 = 0;

추상 클래스에 정의된 가상함수는 자식 클래스에서 꼭 정의되어야 함

-override
메서드원형 override{구현내용}
가독성 / 유지보수성 용이








